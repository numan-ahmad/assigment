{"version":3,"file":"Analytics.js","sources":["../../../../src/core/Analytics/Analytics.ts"],"sourcesContent":["import CollectId from '../Services/analytics/collect-id';\nimport EventsQueue, { EventsQueueModule } from './EventsQueue';\nimport { AnalyticsEvent, AnalyticsInitialEvent, AnalyticsObject, AnalyticsProps, CreateAnalyticsEventObject } from './types';\nimport { ANALYTIC_LEVEL, ANALYTICS_INFO_TIMER_INTERVAL, ANALYTICS_PATH, ANALYTICS_EVENT } from './constants';\nimport { debounce } from '../../utils/debounce';\nimport { AnalyticsModule } from '../../types/global-types';\nimport { createAnalyticsObject, processAnalyticsData } from './utils';\nimport { analyticsPreProcessor } from './analyticsPreProcessor';\n\nlet capturedCheckoutAttemptId = null;\nlet sendEventsTimerId = null;\n\nconst Analytics = ({ locale, clientKey, analytics, amount, analyticsContext, bundleType }: AnalyticsProps): AnalyticsModule => {\n    const defaultProps = {\n        enabled: true,\n        checkoutAttemptId: null,\n        analyticsData: {}\n    };\n\n    const props = { ...defaultProps, ...analytics };\n\n    const collectId = CollectId({ analyticsContext, clientKey, locale, amount, analyticsPath: ANALYTICS_PATH, bundleType });\n    const eventsQueue: EventsQueueModule = EventsQueue({ analyticsContext, clientKey, analyticsPath: ANALYTICS_PATH });\n\n    const sendAnalyticsEvents = () => {\n        if (capturedCheckoutAttemptId) {\n            return eventsQueue.run(capturedCheckoutAttemptId);\n        }\n        return Promise.resolve(null);\n    };\n\n    const addAnalyticsEvent = (type: AnalyticsEvent, obj: AnalyticsObject) => {\n        const arrayName = type === ANALYTICS_EVENT.info ? type : `${type}s`;\n        eventsQueue.add(`${arrayName}`, obj);\n\n        /**\n         * The logic is:\n         *  - info events are stored until a log or error comes along,\n         *  but, if after a set time, no other analytics event (log or error) has come along then we send the info events anyway\n         */\n        if (type === ANALYTICS_EVENT.info) {\n            clearTimeout(sendEventsTimerId);\n            sendEventsTimerId = setTimeout(() => void sendAnalyticsEvents(), ANALYTICS_INFO_TIMER_INTERVAL);\n        }\n\n        /**\n         * The logic is:\n         *  - errors and logs get sent straightaway\n         *  ...but... tests with the 3DS2 process show that many logs can happen almost at the same time (or you can have an error followed immediately by a log),\n         *  so instead of making several sequential api calls we see if we can \"batch\" them using debounce\n         */\n        if (type === ANALYTICS_EVENT.log || type === ANALYTICS_EVENT.error) {\n            clearTimeout(sendEventsTimerId); // clear any timer that might be about to dispatch the info events array\n\n            debounce(sendAnalyticsEvents)();\n        }\n    };\n\n    const anlModule: AnalyticsModule = {\n        /**\n         * Make \"setup\" call, to pass containerWidth, buildType, channel etc, and receive a checkoutAttemptId in return\n         * @param initialEvent -\n         */\n        setUp: async (initialEvent: AnalyticsInitialEvent) => {\n            const { payload, enabled } = props; // TODO what is payload, is it ever used?\n            const level = enabled ? ANALYTIC_LEVEL.all : ANALYTIC_LEVEL.initial;\n            const analyticsData = processAnalyticsData(props.analyticsData);\n            if (!capturedCheckoutAttemptId) {\n                try {\n                    capturedCheckoutAttemptId = await collectId({\n                        ...initialEvent,\n                        ...(payload && { ...payload }),\n                        ...(Object.keys(analyticsData).length && { ...analyticsData }),\n                        ...{ level }\n                    });\n                } catch (e: any) {\n                    console.warn(`Fetching checkoutAttemptId failed.${e ? ` Error=${e}` : ''}`);\n                }\n            }\n        },\n\n        getCheckoutAttemptId: (): string => capturedCheckoutAttemptId,\n\n        // Expose getter for testing purposes\n        getEventsQueue: () => eventsQueue,\n\n        createAnalyticsEvent: ({ event, data }: CreateAnalyticsEventObject): AnalyticsObject => {\n            if (!props.enabled) return;\n\n            const aObj: AnalyticsObject = createAnalyticsObject({\n                event,\n                ...data\n            });\n            // console.log('### Analytics::createAnalyticsEvent:: event=', event, ' aObj=', aObj);\n\n            addAnalyticsEvent(event, aObj);\n\n            return aObj;\n        },\n\n        getEnabled: () => props.enabled,\n\n        sendAnalytics: null\n    };\n\n    anlModule.sendAnalytics = props.enabled === true ? analyticsPreProcessor(anlModule) : () => {};\n\n    return anlModule;\n};\n\nexport default Analytics;\n"],"names":["capturedCheckoutAttemptId","sendEventsTimerId","Analytics","locale","clientKey","analytics","amount","analyticsContext","bundleType","props","_object_spread","enabled","checkoutAttemptId","analyticsData","collectId","CollectId","analyticsPath","ANALYTICS_PATH","eventsQueue","EventsQueue","sendAnalyticsEvents","run","Promise","resolve","anlModule","setUp","async","initialEvent","payload","level","ANALYTIC_LEVEL","all","initial","processAnalyticsData","Object","keys","length","e","console","warn","getCheckoutAttemptId","getEventsQueue","createAnalyticsEvent","event","data","aObj","createAnalyticsObject","type","obj","arrayName","ANALYTICS_EVENT","info","add","clearTimeout","setTimeout","ANALYTICS_INFO_TIMER_INTERVAL","log","error","debounce","addAnalyticsEvent","getEnabled","sendAnalytics","analyticsPreProcessor"],"mappings":"k1BASA,IAAIA,EAA4B,KAC5BC,EAAoB,KAExB,MAAMC,EAAY,EAAGC,SAAQC,YAAWC,YAAWC,SAAQC,mBAAkBC,iBACzE,MAMMC,EAAQC,KANO,CACjBC,SAAS,EACTC,kBAAmB,KACnBC,cAAe,CAAC,GAGgBR,GAE9BS,EAAYC,EAAU,CAAER,mBAAkBH,YAAWD,SAAQG,SAAQU,cAAeC,EAAgBT,eACpGU,EAAiCC,EAAY,CAAEZ,mBAAkBH,YAAWY,cAAeC,IAE3FG,EAAsB,IACpBpB,EACOkB,EAAYG,IAAIrB,GAEpBsB,QAAQC,QAAQ,MA8BrBC,EAA6B,CAK/BC,MAAOC,MAAOC,IACV,MAAMC,QAAEA,EAAOjB,QAAEA,GAAYF,EACvBoB,EAAQlB,EAAUmB,EAAeC,IAAMD,EAAeE,QACtDnB,EAAgBoB,EAAqBxB,EAAMI,eACjD,IAAKb,EACD,IACIA,QAAkCc,EAAUJ,EACrCiB,CAAAA,EAAAA,EACCC,GAAWlB,EAAKkB,CAAAA,EAAAA,GAChBM,OAAOC,KAAKtB,GAAeuB,QAAU1B,KAAKG,GAC3C,CAAEgB,UAEb,CAAE,MAAOQ,GACLC,QAAQC,KAAK,sCAAqCF,EAAI,UAAUA,IAAM,IAC1E,CACJ,EAGJG,qBAAsB,IAAcxC,EAGpCyC,eAAgB,IAAMvB,EAEtBwB,qBAAsB,EAAGC,QAAOC,WAC5B,IAAKnC,EAAME,QAAS,OAEpB,MAAMkC,EAAwBC,EAAsBpC,EAAA,CAChDiC,SACGC,IAMP,MAlEkB,EAACG,EAAsBC,KAC7C,MAAMC,EAAYF,IAASG,EAAgBC,KAAOJ,EAAO,GAAGA,KAC5D7B,EAAYkC,IAAI,GAAGH,IAAaD,GAO5BD,IAASG,EAAgBC,OACzBE,aAAapD,GACbA,EAAoBqD,YAAW,KAAWlC,GAAuBmC,GAAAA,IASjER,IAASG,EAAgBM,KAAOT,IAASG,EAAgBO,QACzDJ,aAAapD,GAEbyD,EAAStC,EAATsC,GACJ,EAwCIC,CAAkBhB,EAAOE,GAElBA,CAAAA,EAGXe,WAAY,IAAMnD,EAAME,QAExBkD,cAAe,MAKnB,OAFArC,EAAUqC,eAAkC,IAAlBpD,EAAME,QAAmBmD,EAAsBtC,GAAa,OAE/EA,CAAAA"}