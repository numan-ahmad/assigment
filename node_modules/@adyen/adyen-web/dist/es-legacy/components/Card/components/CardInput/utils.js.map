{"version":3,"file":"utils.js","sources":["../../../../../../src/components/Card/components/CardInput/utils.ts"],"sourcesContent":["import Language from '../../../../language/Language';\nimport { AddressModeOptions, CardInputProps, LayoutObj } from './types';\nimport {\n    CREDIT_CARD,\n    CREDIT_CARD_NAME_BOTTOM,\n    CREDIT_CARD_NAME_TOP,\n    KCP_CARD,\n    KCP_CARD_NAME_BOTTOM,\n    KCP_CARD_NAME_TOP,\n    SSN_CARD,\n    SSN_CARD_NAME_BOTTOM,\n    SSN_CARD_NAME_TOP\n} from './layouts';\nimport { AddressSpecifications, StringObject } from '../../../internal/Address/types';\nimport { PARTIAL_ADDRESS_SCHEMA } from '../../../internal/Address/constants';\nimport { InstallmentsObj } from './components/Installments/Installments';\nimport { SFPProps } from '../../../internal/SecuredFields/SFP/types';\nimport { BRAND_READABLE_NAME_MAP } from '../../../internal/SecuredFields/lib/constants';\nimport { UseImageHookType } from '../../../../core/Context/useImage';\nimport { SF_ErrorCodes } from '../../../../core/Errors/constants';\n\nexport const getCardImageUrl = (brand: string, getImage: UseImageHookType): string => {\n    const imageOptions = {\n        type: brand === 'card' ? 'nocard' : brand || 'nocard',\n        extension: 'svg'\n    };\n\n    return getImage(imageOptions)(brand);\n};\n\n/**\n * Verifies that installment object is valid to send to the Backend.\n * Valid means that it has 'revolving' plan set, or the number of installments is bigger than one\n */\nexport const hasValidInstallmentsObject = (installments?: InstallmentsObj) => {\n    return installments?.plan === 'revolving' || installments?.value > 1;\n};\n\nexport const getLayout = ({\n    props,\n    showKCP,\n    showBrazilianSSN,\n    countrySpecificSchemas = null,\n    billingAddressRequiredFields = null\n}: LayoutObj): string[] => {\n    let layout = CREDIT_CARD;\n    const hasRequiredHolderName = props.hasHolderName && props.holderNameRequired;\n\n    if (hasRequiredHolderName) {\n        layout = props.positionHolderNameOnTop ? CREDIT_CARD_NAME_TOP : CREDIT_CARD_NAME_BOTTOM;\n    }\n\n    if (showKCP) {\n        layout = KCP_CARD;\n        if (hasRequiredHolderName) {\n            layout = props.positionHolderNameOnTop ? KCP_CARD_NAME_TOP : KCP_CARD_NAME_BOTTOM;\n        }\n    }\n\n    if (showBrazilianSSN) {\n        layout = SSN_CARD;\n        if (hasRequiredHolderName) {\n            layout = props.positionHolderNameOnTop ? SSN_CARD_NAME_TOP : SSN_CARD_NAME_BOTTOM;\n        }\n    }\n\n    // w. Billing address\n    if (countrySpecificSchemas) {\n        // Flatten array and remove any numbers that describe how fields should be aligned\n        const countrySpecificSchemasFlat: string[] = countrySpecificSchemas['flat'](2).filter(item => typeof item !== 'number') as string[];\n\n        let countryBasedAddressLayout = countrySpecificSchemasFlat;\n\n        if (billingAddressRequiredFields) {\n            // Get intersection of the 2 arrays\n            countryBasedAddressLayout = countrySpecificSchemasFlat.filter(x => billingAddressRequiredFields.includes(x));\n        }\n\n        layout = CREDIT_CARD.concat(countryBasedAddressLayout);\n        if (hasRequiredHolderName) {\n            layout = props.positionHolderNameOnTop\n                ? CREDIT_CARD_NAME_TOP.concat(countryBasedAddressLayout)\n                : CREDIT_CARD_NAME_BOTTOM.concat(countryBasedAddressLayout);\n        }\n        // TODO we are not yet creating a layout for AVS + SSN field (w. or w/o holderName) - is AVS + SSN a real world scenario?\n    }\n    return layout;\n};\n\n/**\n * Lookup service to map local (CardInput) field refs to a key, possibly region specific, by which to retrieve the translation\n */\nexport const mapFieldKey = (key: string, i18n: Language, countrySpecificLabels: StringObject): string => {\n    // console.log('### utils::mapFieldKey:: key', key);\n    switch (key) {\n        case 'socialSecurityNumber':\n            return i18n.get(`boleto.${key}`);\n        // Address related - if we have a country specific key for the field - use that to get the translation\n        case 'street':\n        case 'houseNumberOrName':\n        case 'postalCode':\n        case 'stateOrProvince':\n        case 'city':\n        case 'country':\n            return countrySpecificLabels?.[key] ? i18n.get(countrySpecificLabels?.[key]) : i18n.get(key);\n        // We know that the translated error messages do contain a reference to the field they refer to, so we won't need to map them (currently applies mostly to SecuredFields related errors)\n        default:\n            return null;\n    }\n};\n\nexport const extractPropsForCardFields = (props: CardInputProps) => {\n    return {\n        // Extract props for CardFieldsWrapper & StoredCardFieldsWrapper(just needs amount, hasCVC, installmentOptions)\n        amount: props.amount,\n        billingAddressRequired: props.billingAddressRequired,\n        billingAddressRequiredFields: props.billingAddressRequiredFields,\n        billingAddressAllowedCountries: props.billingAddressAllowedCountries,\n        brandsConfiguration: props.brandsConfiguration,\n        showStoreDetailsCheckbox: props.showStoreDetailsCheckbox,\n        hasCVC: props.hasCVC,\n        hasHolderName: props.hasHolderName,\n        holderNameRequired: props.holderNameRequired,\n        installmentOptions: props.installmentOptions,\n        placeholders: props.placeholders,\n        positionHolderNameOnTop: props.positionHolderNameOnTop,\n        // Extract props for CardFields > CardNumber\n        showBrandIcon: props.showBrandIcon,\n        showContextualElement: props.showContextualElement,\n        // Extract props for StoredCardFields\n        lastFour: props.lastFour,\n        expiryMonth: props.expiryMonth,\n        expiryYear: props.expiryYear,\n        disclaimerMessage: props.disclaimerMessage\n    };\n};\n\nexport const extractPropsForSFP = (props: CardInputProps) => {\n    return {\n        autoFocus: props.autoFocus,\n        brands: props.brands,\n        brandsConfiguration: props.brandsConfiguration,\n        clientKey: props.clientKey,\n        countryCode: props.countryCode,\n        forceCompat: props.forceCompat,\n        i18n: props.i18n,\n        implementationType: props.implementationType,\n        keypadFix: props.keypadFix,\n        legacyInputMode: props.legacyInputMode,\n        loadingContext: props.loadingContext,\n        maskSecurityCode: props.maskSecurityCode,\n        exposeExpiryDate: props.exposeExpiryDate,\n        minimumExpiryDate: props.minimumExpiryDate,\n        onAdditionalSFConfig: props.onAdditionalSFConfig,\n        onAdditionalSFRemoved: props.onAdditionalSFRemoved,\n        onAllValid: props.onAllValid,\n        onAutoComplete: props.onAutoComplete,\n        onBinValue: props.onBinValue,\n        onConfigSuccess: props.onConfigSuccess,\n        handleKeyPress: props.handleKeyPress,\n        onError: props.onError,\n        onFieldValid: props.onFieldValid,\n        onLoad: props.onLoad,\n        placeholders: props.placeholders,\n        resources: props.resources,\n        showContextualElement: props.showContextualElement,\n        showWarnings: props.showWarnings,\n        trimTrailingSeparator: props.trimTrailingSeparator\n    } as SFPProps; // Can't set as return type on fn or it will complain about missing, mandatory, props\n};\n\nexport const handlePartialAddressMode = (addressMode: AddressModeOptions): AddressSpecifications | null => {\n    return addressMode == AddressModeOptions.partial ? PARTIAL_ADDRESS_SCHEMA : null;\n};\n\n// Almost all errors are blur based, but some SF ones are not i.e. when an unsupported card is entered or the expiry date is out of range\nexport function lookupBlurBasedErrors(errorCode) {\n    return ![\n        SF_ErrorCodes.ERROR_MSG_UNSUPPORTED_CARD_ENTERED,\n        SF_ErrorCodes.ERROR_MSG_CARD_TOO_OLD,\n        SF_ErrorCodes.ERROR_MSG_CARD_TOO_FAR_IN_FUTURE,\n        SF_ErrorCodes.ERROR_MSG_CARD_EXPIRES_TOO_SOON\n    ].includes(errorCode);\n}\n\nexport function getFullBrandName(brand) {\n    return BRAND_READABLE_NAME_MAP[brand] ?? brand;\n}\n"],"names":["getCardImageUrl","brand","getImage","type","extension","hasValidInstallmentsObject","installments","plan","value","getLayout","props","showKCP","showBrazilianSSN","countrySpecificSchemas","billingAddressRequiredFields","layout","CREDIT_CARD","hasRequiredHolderName","hasHolderName","holderNameRequired","positionHolderNameOnTop","CREDIT_CARD_NAME_TOP","CREDIT_CARD_NAME_BOTTOM","KCP_CARD","KCP_CARD_NAME_TOP","KCP_CARD_NAME_BOTTOM","SSN_CARD","SSN_CARD_NAME_TOP","SSN_CARD_NAME_BOTTOM","countrySpecificSchemasFlat","filter","item","countryBasedAddressLayout","x","includes","concat","mapFieldKey","key","i18n","countrySpecificLabels","get","extractPropsForCardFields","amount","billingAddressRequired","billingAddressAllowedCountries","brandsConfiguration","showStoreDetailsCheckbox","hasCVC","installmentOptions","placeholders","showBrandIcon","showContextualElement","lastFour","expiryMonth","expiryYear","disclaimerMessage","extractPropsForSFP","autoFocus","brands","clientKey","countryCode","forceCompat","implementationType","keypadFix","legacyInputMode","loadingContext","maskSecurityCode","exposeExpiryDate","minimumExpiryDate","onAdditionalSFConfig","onAdditionalSFRemoved","onAllValid","onAutoComplete","onBinValue","onConfigSuccess","handleKeyPress","onError","onFieldValid","onLoad","resources","showWarnings","trimTrailingSeparator","handlePartialAddressMode","addressMode","AddressModeOptions","partial","PARTIAL_ADDRESS_SCHEMA","lookupBlurBasedErrors","errorCode","SF_ErrorCodes","ERROR_MSG_UNSUPPORTED_CARD_ENTERED","ERROR_MSG_CARD_TOO_OLD","ERROR_MSG_CARD_TOO_FAR_IN_FUTURE","ERROR_MSG_CARD_EXPIRES_TOO_SOON","getFullBrandName","BRAND_READABLE_NAME_MAP"],"mappings":"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"}