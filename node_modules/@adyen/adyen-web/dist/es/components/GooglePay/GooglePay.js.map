{"version":3,"file":"GooglePay.js","sources":["../../../../src/components/GooglePay/GooglePay.tsx"],"sourcesContent":["import { h } from 'preact';\nimport UIElement from '../internal/UIElement/UIElement';\nimport GooglePayService from './GooglePayService';\nimport GooglePayButton from './components/GooglePayButton';\nimport defaultProps from './defaultProps';\nimport { formatGooglePayContactToAdyenAddressFormat, getGooglePayLocale } from './utils';\nimport collectBrowserInfo from '../../utils/browserInfo';\nimport AdyenCheckoutError from '../../core/Errors/AdyenCheckoutError';\nimport { TxVariants } from '../tx-variants';\nimport { sanitizeResponse, verifyPaymentDidNotFail } from '../internal/UIElement/utils';\nimport { ANALYTICS_INSTANT_PAYMENT_BUTTON, ANALYTICS_SELECTED_STR } from '../../core/Analytics/constants';\nimport { SendAnalyticsObject } from '../../core/Analytics/types';\n\nimport type { AddressData, BrowserInfo, PaymentResponseData, RawPaymentResponse } from '../../types/global-types';\nimport type { GooglePayConfiguration } from './types';\nimport type { ICore } from '../../core/types';\n\nclass GooglePay extends UIElement<GooglePayConfiguration> {\n    public static type = TxVariants.googlepay;\n    public static txVariants = [TxVariants.googlepay, TxVariants.paywithgoogle];\n    public static defaultProps = defaultProps;\n\n    protected readonly googlePay;\n\n    constructor(checkout: ICore, props?: GooglePayConfiguration) {\n        super(checkout, props);\n        this.handleAuthorization = this.handleAuthorization.bind(this);\n\n        const { isExpress, paymentDataCallbacks } = this.props;\n\n        if (isExpress === false && paymentDataCallbacks?.onPaymentDataChanged) {\n            throw new AdyenCheckoutError(\n                'IMPLEMENTATION_ERROR',\n                'GooglePay - You must set \"isExpress\" flag to \"true\" in order to use \"onPaymentDataChanged\" callback'\n            );\n        }\n\n        this.googlePay = new GooglePayService(this.props.environment, {\n            ...(isExpress && paymentDataCallbacks?.onPaymentDataChanged && { onPaymentDataChanged: paymentDataCallbacks.onPaymentDataChanged }),\n            onPaymentAuthorized: this.onPaymentAuthorized\n        });\n    }\n\n    protected override formatProps(props): GooglePayConfiguration {\n        const buttonSizeMode = props.buttonSizeMode ?? (props.isDropin ? 'fill' : 'static');\n        const buttonLocale = getGooglePayLocale(props.buttonLocale ?? props.i18n?.locale);\n\n        const callbackIntents: google.payments.api.CallbackIntent[] = [...props.callbackIntents, 'PAYMENT_AUTHORIZATION'];\n\n        return {\n            ...props,\n            configuration: props.configuration,\n            buttonSizeMode,\n            buttonLocale,\n            callbackIntents\n        };\n    }\n\n    /**\n     * Formats the component data output\n     */\n    protected override formatData() {\n        const { googlePayCardNetwork, googlePayToken, billingAddress, deliveryAddress } = this.state;\n        const { isExpress } = this.props;\n\n        return {\n            paymentMethod: {\n                type: this.type,\n                googlePayCardNetwork,\n                googlePayToken,\n                ...(isExpress && { subtype: 'express' })\n            },\n            browserInfo: this.browserInfo,\n            origin: !!window && window.location.origin,\n            ...(billingAddress && { billingAddress }),\n            ...(deliveryAddress && { deliveryAddress })\n        };\n    }\n\n    protected submitAnalytics(analyticsObj: SendAnalyticsObject) {\n        // Analytics will need to know about this.props.isExpress & this.props.expressPage\n        super.submitAnalytics({ ...analyticsObj }, this.props);\n    }\n\n    public override submit = () => {\n        // Analytics\n        if (this.props.isInstantPayment) {\n            this.submitAnalytics({ type: ANALYTICS_SELECTED_STR, target: ANALYTICS_INSTANT_PAYMENT_BUTTON });\n        }\n\n        new Promise((resolve, reject) => this.props.onClick(resolve, reject))\n            .then(() => this.googlePay.initiatePayment(this.props, this.core.options.countryCode))\n            .catch((error: google.payments.api.PaymentsError) => {\n                if (error.statusCode === 'CANCELED') {\n                    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n                    this.handleError(new AdyenCheckoutError('CANCEL', error.toString(), { cause: error }));\n                } else {\n                    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n                    this.handleError(new AdyenCheckoutError('ERROR', error.toString(), { cause: error }));\n                }\n            });\n    };\n\n    /**\n     * Method called when the payment is authorized in the payment sheet\n     *\n     * @see https://developers.google.com/pay/api/web/reference/client#onPaymentAuthorized\n     **/\n    private onPaymentAuthorized = async (paymentData: google.payments.api.PaymentData): Promise<google.payments.api.PaymentAuthorizationResult> => {\n        const billingAddress: AddressData = formatGooglePayContactToAdyenAddressFormat(paymentData.paymentMethodData.info.billingAddress);\n        const deliveryAddress: AddressData = formatGooglePayContactToAdyenAddressFormat(paymentData.shippingAddress, true);\n\n        this.setState({\n            authorizedEvent: paymentData,\n            googlePayToken: paymentData.paymentMethodData.tokenizationData.token,\n            googlePayCardNetwork: paymentData.paymentMethodData.info.cardNetwork,\n            ...(billingAddress && { billingAddress }),\n            ...(deliveryAddress && { deliveryAddress })\n        });\n\n        return new Promise<google.payments.api.PaymentAuthorizationResult>(resolve => {\n            this.handleAuthorization()\n                .then(this.makePaymentsCall)\n                .then(sanitizeResponse)\n                .then(verifyPaymentDidNotFail)\n                .then((paymentResponse: PaymentResponseData) => {\n                    resolve({ transactionState: 'SUCCESS' });\n                    return paymentResponse;\n                })\n                .then(paymentResponse => {\n                    this.handleResponse(paymentResponse);\n                })\n                .catch((paymentResponse?: RawPaymentResponse) => {\n                    this.setElementStatus('ready');\n\n                    const googlePayError = paymentResponse?.error?.googlePayError;\n                    const fallbackMessage = this.props.i18n.get('error.subtitle.payment');\n\n                    const error: google.payments.api.PaymentDataError =\n                        typeof googlePayError === 'string' || undefined\n                            ? {\n                                  intent: 'PAYMENT_AUTHORIZATION',\n                                  reason: 'OTHER_ERROR',\n                                  message: (googlePayError as string) || fallbackMessage\n                              }\n                            : {\n                                  intent: googlePayError?.intent || 'PAYMENT_AUTHORIZATION',\n                                  reason: googlePayError?.reason || 'OTHER_ERROR',\n                                  message: googlePayError?.message || fallbackMessage\n                              };\n\n                    resolve({\n                        transactionState: 'ERROR',\n                        error\n                    });\n\n                    const responseWithError = {\n                        ...paymentResponse,\n                        error: {\n                            googlePayError: error\n                        }\n                    };\n\n                    this.handleFailedResult(responseWithError);\n                });\n        });\n    };\n\n    /**\n     * Call the 'onAuthorized' callback if available.\n     * Must be resolved/reject for the payment flow to continue\n     */\n    private async handleAuthorization(): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            if (!this.props.onAuthorized) {\n                resolve();\n            }\n\n            const { authorizedEvent, billingAddress, deliveryAddress } = this.state;\n\n            this.props.onAuthorized(\n                {\n                    authorizedEvent,\n                    ...(billingAddress && { billingAddress }),\n                    ...(deliveryAddress && { deliveryAddress })\n                },\n                { resolve, reject }\n            );\n        }).catch((error?: google.payments.api.PaymentDataError | string) => {\n            // Format error in a way that the 'catch' of the 'onPaymentAuthorize' block accepts it\n            const data = { error: { googlePayError: error } };\n            return Promise.reject(data);\n        });\n    }\n\n    /**\n     * Validation\n     */\n    get isValid(): boolean {\n        return !!this.state.googlePayToken;\n    }\n\n    /**\n     * Determine a shopper's ability to return a form of payment from the Google Pay API.\n     */\n    public override async isAvailable(): Promise<void> {\n        return this.isReadyToPay()\n            .then(response => {\n                if (!response.result) {\n                    throw new AdyenCheckoutError('ERROR', 'GooglePay is not available');\n                }\n\n                if (response.paymentMethodPresent === false) {\n                    throw new AdyenCheckoutError('ERROR', 'GooglePay - No paymentMethodPresent');\n                }\n\n                return Promise.resolve();\n            })\n            .catch(error => {\n                return Promise.reject(error);\n            });\n    }\n\n    /**\n     * Determine a shopper's ability to return a form of payment from the Google Pay API.\n     */\n    public isReadyToPay = (): Promise<google.payments.api.IsReadyToPayResponse> => {\n        return this.googlePay.isReadyToPay(this.props);\n    };\n\n    /**\n     * Use this method to prefetch a PaymentDataRequest configuration to improve loadPaymentData execution time on later user interaction. No value is returned.\n     */\n    public prefetch = (): void => {\n        return this.googlePay.prefetchPaymentData(this.props, this.core.options.countryCode);\n    };\n\n    get browserInfo(): BrowserInfo {\n        return collectBrowserInfo();\n    }\n\n    get icon(): string {\n        return this.props.icon ?? this.resources.getImage()('googlepay');\n    }\n\n    render() {\n        if (this.props.showPayButton) {\n            return (\n                <GooglePayButton\n                    buttonColor={this.props.buttonColor}\n                    buttonType={this.props.buttonType}\n                    buttonSizeMode={this.props.buttonSizeMode}\n                    buttonLocale={this.props.buttonLocale}\n                    buttonRootNode={this.props.buttonRootNode}\n                    buttonRadius={this.props.buttonRadius}\n                    paymentsClient={this.googlePay.paymentsClient}\n                    onClick={this.submit}\n                />\n            );\n        }\n\n        return null;\n    }\n}\n\nexport default GooglePay;\n"],"names":["GooglePay","UIElement","formatProps","props","buttonSizeMode","isDropin","buttonLocale","getGooglePayLocale","i18n","locale","callbackIntents","configuration","formatData","googlePayCardNetwork","googlePayToken","billingAddress","deliveryAddress","this","state","isExpress","paymentMethod","type","subtype","browserInfo","origin","window","location","submitAnalytics","analyticsObj","super","handleAuthorization","Promise","resolve","reject","onAuthorized","authorizedEvent","catch","error","data","googlePayError","isValid","isAvailable","isReadyToPay","then","response","result","AdyenCheckoutError","paymentMethodPresent","collectBrowserInfo","icon","resources","getImage","render","showPayButton","h","GooglePayButton","buttonColor","buttonType","buttonRootNode","buttonRadius","paymentsClient","googlePay","onClick","submit","constructor","checkout","_define_property","isInstantPayment","ANALYTICS_SELECTED_STR","target","ANALYTICS_INSTANT_PAYMENT_BUTTON","initiatePayment","core","options","countryCode","statusCode","handleError","toString","cause","onPaymentAuthorized","async","paymentData","formatGooglePayContactToAdyenAddressFormat","paymentMethodData","info","shippingAddress","setState","tokenizationData","token","cardNetwork","makePaymentsCall","sanitizeResponse","verifyPaymentDidNotFail","paymentResponse","transactionState","handleResponse","setElementStatus","fallbackMessage","get","intent","reason","message","responseWithError","handleFailedResult","prefetch","prefetchPaymentData","bind","paymentDataCallbacks","onPaymentDataChanged","GooglePayService","environment","TxVariants","googlepay","txVariants","paywithgoogle","defaultProps"],"mappings":"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"}